---
title: "Identifying sudden changes in infectivity"
author: "Vicente J. Ontiveros"
date: "10/4/2023"
output: ioslides_presentation
---

## Aim of these experiments

- Recover a time-varying infectivity parameter in an age-structured SIR with a simple SIR.
- Develop an expert system that detects structural changes.

----
**Algorithm**: Moving windows.
----

1. Set up initial values for the parameter.
2. For a given window length, estimate the parameters of the model.
3. Set up the parameters as the new initial values.
4. Move the window a given step length. 
5. Repeat 2-4 until a desired condition. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = F, message = F)
library(tidyverse)
library(deSolve)
# library(dplyr)
library(lhs)
# library(ggplot2)
# library(tibble)
# library(utils)
library(lubridate)
# library(tidyr)
library(strucchange)
library(modeest)

source("ll_function_v6.R")
source("R/fitting_procedure_v5.R")
source('compilation.R')

dyn.load("src/SIR.so")
```

# Naked moving windows

## First example

```{r}
data <- read.csv("data/artificial230207_Age2.csv", na.strings = "", fileEncoding = "UTF-8-BOM")

selected_country <- "SIRDageComplex-IotaScale0.5-S0_SSA-s0_N100000"
country <-
  data %>% filter(countriesAndTerritories == selected_country) %>% 
  select(dateRep, cases, countriesAndTerritories, popData2020, infected, recovered, dead) %>% 
  separate(infected, sep = ",", letters[1:3]) %>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         infected = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% 
  separate(recovered, sep = ",", letters[1:3]) %>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         recovered = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% 
  separate(dead, sep = ",", letters[1:3])%>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         dead = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% select(-letters[1:3]) %>% 
  select(dateRep, cases, countriesAndTerritories, popData2020, infected, recovered, dead) %>% 
  mutate(date_new = dmy(dateRep)) %>% arrange(date_new)

sims <- 3 #number of "threads" to be optimized
days <- 70 #number of jumps of the timestep

seeds <- randomLHS(sims, 1)
seeds <- t(seeds) * c(.5)
set.seed(476468713)
pop <- country$popData2020[1]

wl.df <- data.frame()

for(wl in 5:21){
  seq_pars <- data.frame(iota = rep(NA, sims*days), day = rep(NA, sims*days))
  
  #### Fitting
  
  start_0 <- as.Date("2020-02-24")
  
  for(i in 0:(days - 1)){
    start <- start_0 + i
    end <- start + wl - 1
    
    n_start <- which(country$date_new == start)
    n_end <- which(country$date_new == end)
    input <- country[n_start:n_end, ]
    
    devs <- c()
    spl <- (input$cases)
    fit <- smooth.spline(x = 1:nrow(input), y = spl, df = 4)
    devs <- sd(spl - predict(fit)$y)
    
    if(devs < .5) devs <- 1
    
    temp <- fitting_procedure(seeds = seeds, fun = ll_ode, data = input, stdev = devs, pop = pop, rho = .03, i_0 = country$infected[n_start - 1], r_0 = country$recovered[n_start - 1] + country$dead[n_start - 1])
    
    temp <- as.data.frame(temp)
    colnames(temp) <- c("iota")
    
    seq_pars[(1 + sims * i):(sims + sims * i), ] <-  
      temp %>% add_column(day = i)
    
    
    rm(temp)
    
  }
seq_pars <- seq_pars %>% add_column(Window.length = wl)
  wl.df <- rbind(wl.df, seq_pars)
}

wl.df <- wl.df %>% unique()

ggplot(wl.df, aes(x = day, y = iota, group = Window.length, color = Window.length)) + 
   # geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") + 
  geom_vline(xintercept = 30) +
  geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) +
  # geom_line(aes(x = day + Window.length), linetype = 2) +
  xlab("Day") + ylab("Infectivity")

```

Sudden change to 50% infectivity at day 30.


## Second example

```{r}
selected_country <- "SIRDageComplex-IotaScale0.5-S3_SSA-s0_N100000"
country <-
  data %>% filter(countriesAndTerritories == selected_country) %>% 
  select(dateRep, cases, countriesAndTerritories, popData2020, infected, recovered, dead) %>% 
  separate(infected, sep = ",", letters[1:3]) %>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         infected = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% 
  separate(recovered, sep = ",", letters[1:3]) %>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         recovered = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% 
  separate(dead, sep = ",", letters[1:3])%>% 
  mutate(a = str_sub(a, start = 2), c = str_sub(c, end = -2), 
         dead = as.numeric(a) + as.numeric(b) + as.numeric(c)) %>% select(-letters[1:3]) %>% 
  select(dateRep, cases, countriesAndTerritories, popData2020, infected, recovered, dead) %>% 
  mutate(date_new = dmy(dateRep)) %>% arrange(date_new)

sims <- 3 #number of "threads" to be optimized
days <- 70 #number of jumps of the timestep

seeds <- randomLHS(sims, 1)
seeds <- t(seeds) * c(.5)
set.seed(476468713)
pop <- country$popData2020[1]

wl2.df <- data.frame()

for(wl in 5:21){
  seq_pars <- data.frame(iota = rep(NA, sims*days), day = rep(NA, sims*days))
  
  #### Fitting
  
  start_0 <- as.Date("2020-02-24")
  
  for(i in 0:(days - 1)){
    start <- start_0 + i
    end <- start + wl - 1
    
    n_start <- which(country$date_new == start)
    n_end <- which(country$date_new == end)
    input <- country[n_start:n_end, ]
    
    devs <- c()
    spl <- (input$cases)
    fit <- smooth.spline(x = 1:nrow(input), y = spl, df = 4)
    devs <- sd(spl - predict(fit)$y)
    
    if(devs < .5) devs <- 1
    
    temp <- fitting_procedure(seeds = seeds, fun = ll_ode, data = input, stdev = devs, pop = pop, rho = .03, i_0 = country$infected[n_start - 1], r_0 = country$recovered[n_start - 1] + country$dead[n_start - 1])
    
    temp <- as.data.frame(temp)
    colnames(temp) <- c("iota")
    
    seq_pars[(1 + sims * i):(sims + sims * i), ] <-  
      temp %>% add_column(day = i)
    
    
    rm(temp)
    
  }
seq_pars <- seq_pars %>% add_column(Window.length = wl)
  wl2.df <- rbind(wl2.df, seq_pars)
}

wl2.df <- wl2.df %>% unique()

ggplot(wl2.df, aes(x = day, y = iota, group = Window.length, color = Window.length)) + 
   geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  # geom_vline(xintercept = 30) +
  geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) +
  # geom_line(aes(x = day + Window.length), linetype = 2) +
  xlab("Day") + ylab("Infectivity")

```

Linear decrease in infectivity from day 22 to 38.


# Searching for automatic approaches

## Linear decrease

```{r}
chow.df <- data.frame()

approach <- wl2.df %>% group_by(day) %>% summarise(sd = sd(iota)) %>% as.data.frame()

temp2 <- data.frame()
for(i in 7:64){
  for(wl in 5:20){
    if((i - wl) < 1) next
    if((i + wl) > 70) next
    temp_data <- approach %>% slice((i - wl):(i + wl))
    chow <- (sctest(temp_data$sd ~ temp_data$day,
               type = 'Chow', point = (wl + 1)))$statistic
    temp2 <- rbind(temp2, data.frame(Focal = i, wl = wl, statistic = chow))
  }
}
# temp2



ggplot(temp2, aes(x = Focal, y = statistic, color = wl, group = wl)) +
  geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") + 
  geom_line(alpha = .33) + theme_bw() +
  # geom_vline(xintercept = 30) +
  geom_line(data = temp2 %>% group_by(Focal) %>% summarise(Sd = mean(statistic)), aes(x = Focal + 1, y = Sd), color = "Magenta", size = 1) +
  xlab("Day")
```

Moving windows -> sd -> Chow test multiple window lengths (blue) -> Mean (magenta)

## Sudden change

```{r}
chow.df <- data.frame()

approach <- wl.df %>% group_by(day) %>% summarise(sd = sd(iota)) %>% as.data.frame()

temp2 <- data.frame()
for(i in 7:64){
  for(wl in 5:20){
    if((i - wl) < 1) next
    if((i + wl) > 70) next
    temp_data <- approach %>% slice((i - wl):(i + wl))
    chow <- (sctest(temp_data$sd ~ temp_data$day,
               type = 'Chow', point = (wl + 1)))$statistic
    temp2 <- rbind(temp2, data.frame(Focal = i, wl = wl, statistic = chow))
  }
}
# temp2



ggplot(temp2, aes(x = Focal, y = statistic, color = wl, group = wl)) +
  geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") + 
  geom_line(alpha = .33) + theme_bw() +
  # geom_vline(xintercept = 30) +
  geom_line(data = temp2 %>% group_by(Focal) %>% summarise(Sd = mean(statistic)), aes(x = Focal + 1, y = Sd), color = "Magenta", size = 1) +
  xlab("Day")
```

It doesn't work. Let's take a look at the s.d.

## Standard deviation

```{r}
ggplot(wl.df %>% group_by(day) %>% summarise(sd = sd(iota)), aes(x = day, y = sd)) +  
geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) + 
geom_vline(xintercept = 30) + xlab("Day")
```

Standard deviation of the moving windows. 
We were lucky in the linear decrease case.

# Another approach

## Linear change

```{r}
chow.df <- data.frame()

approach <- wl2.df 

temp2 <- data.frame(matrix(nrow = 25600, ncol = 4))
colnames(temp2) <- c("Focal", "win", "wl", "statistic")
n <- 1
for(i in 7:64){
  for(win in 5:20){
    if((i - win) < 1) next
    if((i + win) > 70) next
    for(wl2 in 5:20){
      if((i - wl2) < 1) next
    if((i + wl2) > 70) next
      temp_data <- approach %>% filter(Window.length == wl2) %>% slice((i - win):(i + win))
    chow <- (sctest(temp_data$iota ~ temp_data$day,
               type = 'Chow', point = (win + 1)))$statistic
    temp2[n, ] <- c(Focal = i, win = win, wl2 = wl2, statistic = chow)
    n <- n + 1
    }
  }
}


ggplot(temp2 %>% group_by(Focal) %>% summarise(Statistic = mean(statistic)), aes(x = Focal, y = Statistic)) +
  geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  # geom_point() +
  geom_line() + theme_bw() +
  # geom_vline(xintercept = 30) +
  # geom_line(data = temp2 %>% group_by(Focal) %>% summarise(Sd = mean(statistic)), aes(x = Focal + 1, y = Sd), color = "Magenta", size = 1) +
  xlab("Day")
```

Moving windows -> Chow test at each point -> Mean of the statistic

## Sudden change

```{r}
chow.df <- data.frame()

approach <- wl.df 

temp2 <- data.frame(matrix(nrow = 25600, ncol = 4))
colnames(temp2) <- c("Focal", "win", "wl", "statistic")
n <- 1
for(i in 7:64){
  for(win in 5:20){
    if((i - win) < 1) next
    if((i + win) > 70) next
    for(wl2 in 5:20){
      if((i - wl2) < 1) next
    if((i + wl2) > 70) next
      temp_data <- approach %>% filter(Window.length == wl2) %>% slice((i - win):(i + win))
    chow <- (sctest(temp_data$iota ~ temp_data$day,
               type = 'Chow', point = (win + 1)))$statistic
    temp2[n, ] <- c(Focal = i, win = win, wl2 = wl2, statistic = chow)
    n <- n + 1
    }
  }
}


ggplot(temp2 %>% group_by(Focal) %>% summarise(Statistic = mean(statistic)), aes(x = Focal, y = Statistic)) +
  # geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  # geom_point() +
  geom_line() + theme_bw() +
  geom_vline(xintercept = 30) +
  # geom_line(data = temp2 %>% group_by(Focal) %>% summarise(Sd = mean(statistic)), aes(x = Focal + 1, y = Sd), color = "Magenta", size = 1) +
  xlab("Day")
```

Second peak when the infectivity estimates start to change.

# Yet another approximation

## Two possible conventions

```{r}
ggplot(wl.df, aes(x = day, y = iota, group = Window.length, color = Window.length)) + 
   # geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  geom_vline(xintercept = 30) +
  geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) +
  geom_line(aes(x = day + Window.length), linetype = 2) +
  xlab("Day") + ylab("Infectivity")

```

Actually, we need some kind of deconvolution.

## My shot at deconvolution

```{r}
end.wl.df <- wl.df %>% mutate(day = day + Window.length)

both.wl.df <- rbind(wl.df, end.wl.df)

both.wl.df %<>% group_by(day) %>% 
  summarise(Mean = mean(iota), Median = median(iota), Mode = mlv(iota))

ggplot(both.wl.df %>% pivot_longer(cols = c(Mean, Median, Mode)), aes(x = day, y = value, color = name)) + 
   # geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  geom_vline(xintercept = 30) +
  geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) +
  xlab("Day") + ylab("Infectivity")

```

Great! Let's see the Chow test of this series.

## Chow test

```{r}
chow.df <- data.frame()

chowchow <- both.wl.df %>% select(day, Mode)
# chowchow <- both.wl.df %>% select(day, Median)

temp2 <- data.frame()
for(i in 7:64){
  for(wl in 5:20){
    if((i - wl) < 1) next
    if((i + wl) > 70) next
    temp_data <- chowchow %>% slice((i - wl):(i + wl))
    chow <- (sctest(temp_data$Mode ~ temp_data$day,
    # chow <- (sctest(temp_data$Median ~ temp_data$day,
               type = 'Chow', point = (wl + 1)))$statistic
    temp2 <- rbind(temp2, data.frame(Focal = i, wl = wl, statistic = chow))
  }
}
# temp2

ggplot(temp2, aes(x = Focal, y = statistic, color = wl, group = wl)) +
  geom_vline(xintercept = 30) +
  # geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") + 
  geom_line() + theme_bw() +
  xlab("Day")
```

Perfect result. Let's see with the gradual reduction.

## Second example

```{r}
end.wl.df <- wl2.df %>% mutate(day = day + Window.length)

both.wl.df <- rbind(wl2.df, end.wl.df)

both.wl.df %<>% group_by(day) %>% 
  summarise(Mean = mean(iota), Median = median(iota), Mode = mlv(iota))

ggplot(both.wl.df %>% pivot_longer(cols = c(Mean, Median, Mode)), aes(x = day, y = value, color = name)) + 
   geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") +
  # geom_vline(xintercept = 30) +
  geom_line() + theme_bw() + theme(panel.grid.minor = element_blank()) +
  xlab("Day") + ylab("Infectivity")


```

This mode might well do. Let's do the Chow test.


## Chow test

```{r}
chow.df <- data.frame()

chowchow <- both.wl.df %>% select(day, Mode)
# chowchow <- both.wl.df %>% select(day, Median)

temp2 <- data.frame()
for(i in 7:64){
  for(wl in 5:20){
    if((i - wl) < 1) next
    if((i + wl) > 70) next
    temp_data <- chowchow %>% slice((i - wl):(i + wl))
    chow <- (sctest(temp_data$Mode ~ temp_data$day,
    # chow <- (sctest(temp_data$Median ~ temp_data$day,
               type = 'Chow', point = (wl + 1)))$statistic
    temp2 <- rbind(temp2, data.frame(Focal = i, wl = wl, statistic = chow))
  }
}
# temp2

ggplot(temp2, aes(x = Focal, y = statistic, color = wl, group = wl)) +
  geom_rect(xmin = 22, xmax = 38, ymin = -Inf, ymax = Inf, alpha = .1, color = NA, fill = "grey90") + 
  geom_line() + theme_bw() +
  geom_vline(xintercept = 30) +
  xlab("Day")
```

The Chow test signals more clearly the change in intercept than the two local peaks.


## Conclusion

- "Naked" moving windows do not identify linear decreases.
- Convoluted methods may lead to deceptive peaks.
- Moving Chow tests of the estimates also produce false peaks.
- Pedestrian "deconvolution" shows promise but still it can not identify linear decreases. 

- Is there a way to do a real deconvolution?
